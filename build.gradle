/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn more about Gradle by exploring our samples at https://docs.gradle.org/7.5.1/samples
 */

task startColima() {

    doLast {

        def statusResult = exec {

            commandLine 'colima', 'status'
            ignoreExitValue = true
        }

        if (statusResult.getExitValue() == 1) {

            exec {
                commandLine 'colima', 'start', '--cpu', VM_CPUS, '--memory', VM_MEM_GIGS
            }
        } else {

            println "colima already running"
        }
    }
}

task deployK8sCluster() {

    dependsOn('startColima')

    doLast {

        if (!isMinikubeRunning()) {

            installMinikube()

            enableIngress()

            enableIngressDns()
        } else {

            println "minikube already running"
        }

        useMinikubeCluster()
    }

}

task installMonitoringTools() {

    dependsOn('deployK8sCluster')

    doLast {

        updateHelmRepos()

        createK8sNamespace(MONITORING_NAMESPACE)

        disableMetricsServer()

        if (!isMonitoringChartDeployed()) {

            exec {
                commandLine 'helm', 'install', PROM_HELM_RELEASE_NAME, PROM_HELM_CHART, '-n', MONITORING_NAMESPACE
            }

            println "waiting for monitoring tools to start..."

            exec {
                commandLine 'kubectl',
                            'wait',
                            '--namespace',
                            MONITORING_NAMESPACE,
                            '--for=condition=ready',
                            'pod',
                            "--selector=app.kubernetes.io/name in (grafana, prometheus)",
                            '--timeout=600s'
            }
        }
    }
}

task uninstallMonitoringTools() {

    doLast {
        exec {
            commandLine 'helm', 'uninstall', PROM_HELM_RELEASE_NAME, '-n', MONITORING_NAMESPACE
            ignoreExitValue = true
        }

        exec {

            commandLine 'kubectl', 'delete', 'namespace', MONITORING_NAMESPACE
            ignoreExitValue = true
        }

    }
}

task portForwardGrafana() {

    doLast {
        def grafanaContainerPort = getServicePort(MONITORING_NAMESPACE, "${PROM_HELM_RELEASE_NAME}-grafana", 'http-web')

        println """
    Grafana available at: http://localhost:${GRAFANA_HOST_PORT}
    Login: admin
    Password: prom-operator
            """

        exec {
            commandLine 'kubectl',
                    '-n',
                    MONITORING_NAMESPACE,
                    'port-forward',
                    "service/${PROM_HELM_RELEASE_NAME}-grafana",
                    "${GRAFANA_HOST_PORT}:${grafanaContainerPort}"
        }
    }
}

def installMinikube() {

    exec {

        commandLine 'minikube',
                    'start',
                    '--memory',
                    MINIKUBE_MEM,
                    '--cpus',
                    MINIKUBE_CPUS,
                    '--container-runtime',
                    MINIKUBE_CONTAINER_RUNTIME,
                    '--bootstrapper=kubeadm',
                    '--extra-config=kubelet.authentication-token-webhook=true',
                    '--extra-config=kubelet.authorization-mode=Webhook',
                    '--extra-config=scheduler.bind-address=0.0.0.0',
                    '--extra-config=controller-manager.bind-address=0.0.0.0',
                    "--kubernetes-version=${K8S_VERSION}"
    }
}

def enableIngress() {

    exec {
        commandLine 'minikube', 'addons', 'enable', 'ingress'
    }
}

def createK8sNamespace(name) {

    exec {
        commandLine 'kubectl', 'create', 'namespace', name
        standardOutput = new ByteArrayOutputStream()
        errorOutput = new ByteArrayOutputStream()
        ignoreExitValue = true
    }
}

def useMinikubeCluster() {

    exec {
        commandLine 'kubectl', 'config', 'use-context', 'minikube'
    }
}

def disableMetricsServer() {

    exec {
        commandLine 'minikube', 'addons', 'disable', 'metrics-server'
    }
}

def enableIngressDns() {

    exec {
        commandLine 'minikube', 'addons', 'enable', 'ingress-dns'
    }
}

def isMinikubeRunning() {

    def statusResult = exec {

        commandLine 'minikube', 'status'
        ignoreExitValue = true
    }

    return statusResult.getExitValue() == 0
}

def updateHelmRepos() {

    exec {
        commandLine 'helm',
                    'repo',
                    'add',
                    'prometheus-community',
                    'https://prometheus-community.github.io/helm-charts'
    }

    exec {
        commandLine 'helm', 'repo', 'update'
    }
}

def isMonitoringChartDeployed() {

    def statusResult = exec {
        commandLine 'helm', 'status', PROM_HELM_RELEASE_NAME, '-n', MONITORING_NAMESPACE
        standardOutput = new ByteArrayOutputStream()
        errorOutput = new ByteArrayOutputStream()
        ignoreExitValue = true
    }

    return statusResult.getExitValue() == 0
}

def getServicePort(namespace, serviceName, portName) {

    def templateResult = new ByteArrayOutputStream();

    exec {
        commandLine 'kubectl',
                    '-n',
                    namespace,
                    'get',
                    'service',
                    serviceName,
                    """--template={{range .spec.ports}}{{if eq .name "${portName}"}}{{.port}}{{end}}{{end}}"""
                    standardOutput = templateResult
    }

    return templateResult.toString()
}

